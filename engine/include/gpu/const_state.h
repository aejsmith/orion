/*
 * Copyright (C) 2015 Alex Smith
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/**
 * @file
 * @brief               Constant state holders.
 *
 * @note                This header is not to be included directly, it is
 *                      included from gpu.h, due to circular dependencies
 *                      between this and GPUManager.
 */

#pragma once

#include "gpu/state.h"

/**
 * Constant state holder.
 *
 * This and derived classes are used in the implementation of the templated
 * state set methods in GPUManager. They avoid a hash lookup for the state
 * object by holding a pointer to the state object corresponding to the template
 * arguments.
 */
template <typename State, typename Derived>
class GPUConstState {
public:
    /** @return             State object. */
    static FORCEINLINE State *get() {
        /* By implementing this like this rather than just having a static
         * GPUResourcePtr variable with the initializer here, we make this
         * function much shorter and therefore inlineable. Guard variable stuff
         * generated by the compiler for the initialization is all inserted into
         * the out of line create() function. The pointer here is just inserted
         * into the zero-initialized section of the binary. Thread-safety is not
         * an issue here: the initial creation in create() is guarded by the
         * compiler-generated guard code, and after that point it will always
         * return the same pointer. */
        static State *instance;
        if (unlikely(!instance))
            instance = Derived::create();
        return instance;
    }
};

/** Holder of a constant blend state. */
template <BlendFunc func, BlendFactor sourceFactor, BlendFactor destFactor>
class GPUConstBlendState :
    public GPUConstState<GPUBlendState, GPUConstBlendState<func, sourceFactor, destFactor>> {
public:
    /** @return             Created blend state object. */
    static NOINLINE GPUBlendState *create() {
        GPUBlendStateDesc desc;
        desc.func = func;
        desc.sourceFactor = sourceFactor;
        desc.destFactor = destFactor;

        static GPUBlendStatePtr instance = g_gpuManager->getBlendState(desc);
        return instance;
    }
};

/** Holder of a constant depth/stencil state. */
template <ComparisonFunc depthFunc, bool depthWrite>
class GPUConstDepthStencilState :
    public GPUConstState<GPUDepthStencilState, GPUConstDepthStencilState<depthFunc, depthWrite>> {
public:
    /** @return             Created depth/stencil state object. */
    static NOINLINE GPUDepthStencilState *create() {
        GPUDepthStencilStateDesc desc;
        desc.depthFunc = depthFunc;
        desc.depthWrite = depthWrite;

        static GPUDepthStencilStatePtr instance = g_gpuManager->getDepthStencilState(desc);
        return instance;
    }
};

/** Holder of a constant rasterizer state. */
template <CullMode cullMode, bool depthClamp>
class GPUConstRasterizerState :
    public GPUConstState<GPURasterizerState, GPUConstRasterizerState<cullMode, depthClamp>> {
public:
    /** @return             Created rasterizer state object. */
    static NOINLINE GPURasterizerState *create() {
        GPURasterizerStateDesc desc;
        desc.cullMode = cullMode;
        desc.depthClamp = depthClamp;

        static GPURasterizerStatePtr instance = g_gpuManager->getRasterizerState(desc);
        return instance;
    }
};

/**
 * GPU interface methods.
 */

/** Set the blend state to constant values.
 * @tparam func         Blending function.
 * @tparam sourceFactor Source blend factor.
 * @tparam destFactor   Destination factor. */
template <BlendFunc func, BlendFactor sourceFactor, BlendFactor destFactor>
inline void GPUManager::setBlendState() {
    setBlendState(GPUConstBlendState<func, sourceFactor, destFactor>::get());
}

/** Set the depth/stencil state to constant values.
 * @tparam depthFunc    Depth comparison function.
 * @tparam depthWrite   Whether to enable depth buffer writes. */
template <ComparisonFunc depthFunc, bool depthWrite>
inline void GPUManager::setDepthStencilState() {
    setDepthStencilState(GPUConstDepthStencilState<depthFunc, depthWrite>::get());
}

/** Set the rasterizer state to constant values.
 * @tparam cullMode     Face culling mode.
 * @tparam depthClamp   Whether to enable depth clamping. */
template <CullMode cullMode, bool depthClamp>
inline void GPUManager::setRasterizerState() {
    setRasterizerState(GPUConstRasterizerState<cullMode, depthClamp>::get());
}
